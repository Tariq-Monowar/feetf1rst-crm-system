  //forgot passwors
  fastify.post("/forgotpassword/sendotp", forgotPasswordSendOtp);
  fastify.post("/forgotpassword/verifyotp", forgotPasswordVerifyOtp);
  fastify.post("/forgotpassword/reset", forgotPasswordReset);
  fastify.post("/forgotpassword/recentotp", forgotPasswordRecentOtp);
----------------------------


export const forgotPasswordSendOtp = async (request, reply) => {
  try {
    const { email } = request.body;

    if (!email) {
      return reply.status(400).send({
        success: false,
        // message: "Email is required!",
        message: "murubbi! email koi?",
      });
    }

    const prisma = request.server.prisma;
    const redis = request.server.redis;

    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (!existingUser) {
      return reply.status(404).send({
        success: false,
        // message: "User with this email does not exist",
        message: "murobbi apnar account nai! age register krn?",
      });
    }

    const otp = Math.floor(1000 + Math.random() * 9000).toString();
    const otpExpiry = Date.now() + 5 * 60 * 1000;

    forgotPasswordEmail(email, otp);

    await redis
      .multi()
      .hset(`forgot-password-otp:${email}`, {
        email,
        otp,
        expiration: otpExpiry.toString(),
        userId: existingUser.id.toString(),
        permission_to_update_password: "true",
      })
      .expire(`forgot-password-otp:${email}`, 5 * 60)
      .exec();

    return reply.status(200).send({
      success: true,
      // message: "OTP sent to your email for password reset",
      message: "hay Mr. Flutter Developer! OTP send korechi! apnar email e",
      otp: process.env.NODE_ENV === "development" ? otp : null,
    });
  } catch (error) {
    request.log.error(error);
    return reply.status(500).send({
      success: false,
      // message: "Internal Server Error",
      message: "Flutter Developer durbol!",
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }
};

export const forgotPasswordVerifyOtp = async (request, reply) => {
  try {
    const { email, otp } = request.body;

    const missingField = ["email", "otp"].find((field) => !request.body[field]);

    if (missingField) {
      return reply.status(400).send({
        success: false,
        message: `${missingField} is required!`,
      });
    }

    const redis = request.server.redis;
    const prisma = request.server.prisma;

    const otpData = await redis.hgetall(`forgot-password-otp:${email}`);

    if (!Object.keys(otpData || {}).length) {
      return reply.status(400).send({
        success: false,
        message: "OTP not found or expired!",
      });
    }

    if (otpData.otp !== otp) {
      return reply.status(400).send({
        success: false,
        message: "Invalid OTP!",
      });
    }

    const now = Date.now();
    if (now > parseInt(otpData.expiration)) {
      return reply.status(400).send({
        success: false,
        message: "OTP expired!",
      });
    }

    if (otpData.permission_to_update_password !== "true") {
      return reply.status(400).send({
        success: false,
        message: "Permission to update password not granted!",
      });
    }

    const user = await prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      return reply.status(404).send({
        success: false,
        message: "User not found!",
      });
    }

    await redis.expire(`forgot-password-otp:${email}`, 10 * 60);

    return reply.status(200).send({
      success: true,
      // message: "OTP verified successfully! You can now reset your password.",
      message:
        "hay Mr. Flutter Developer! OTP verified successfully! You can now reset your password.",
    });
  } catch (error) {
    request.log.error(error);
    return reply.status(500).send({
      success: false,
      // message: "Internal Server Error",
      message: "Flutter Developer durbol!",
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }
};

export const forgotPasswordReset = async (request, reply) => {
  try {
    const { email, password } = request.body;

    const missingField = ["email", "password"].find(
      (field) => !request.body[field]
    );

    if (missingField) {
      return reply.status(400).send({
        success: false,
        message: `${missingField} is required!`,
      });
    }

    const redis = request.server.redis;
    const prisma = request.server.prisma;

    const otpData = await redis.hgetall(`forgot-password-otp:${email}`);
    console.log(otpData);

    if (!Object.keys(otpData || {}).length) {
      return reply.status(400).send({
        success: false,
        // message: "Password reset session expired!",
        message: "bodda apnar time expired! abr suro dori krn!",
      });
    }

    if (otpData.permission_to_update_password !== "true") {
      return reply.status(400).send({
        success: false,
        // message: "Permission to update password not granted!",
        message: "amk 500à§³ TK pay krn! thik kre dibo?",
      });
    }

    const user = await prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      return reply.status(404).send({
        success: false,
        message: "User not found!",
      });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    await prisma.user.update({
      where: { email },
      data: { password: hashedPassword },
    });

    await redis.del(`forgot-password-otp:${email}`);

    return reply.status(200).send({
      success: true,
      // message: "Password reset successfully!",
      message: "hay Mr. Flutter Developer! Password reset successfully!",
    });
  } catch (error) {
    request.log.error(error);
    return reply.status(500).send({
      success: false,
      // message: "Internal Server Error",
      message: "Flutter Developer durbol!",
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }
};

export const forgotPasswordRecentOtp = async (request, reply) => {
  try {
    const { email } = request.body;

    if (!email) {
      return reply.status(400).send({
        success: false,
        message: "Email is required!",
      });
    }

    const redis = request.server.redis;
    const prisma = request.server.prisma;

    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (!existingUser) {
      return reply.status(404).send({
        success: false,
        message: "User with this email does not exist",
      });
    }

    const otpData = await redis.hgetall(`forgot-password-otp:${email}`);

    if (!Object.keys(otpData || {}).length) {
      return reply.status(404).send({
        success: false,
        // message: "No active OTP session found. Please request a new OTP.",
        message: "bodda apnar time expired! abr suro dori krn!",
      });
    }

    const newOtp = Math.floor(1000 + Math.random() * 9000).toString();
    const newExpiry = Date.now() + 5 * 60 * 1000;

    await redis
      .multi()
      .hset(`forgot-password-otp:${email}`, {
        ...otpData,
        otp: newOtp,
        expiration: newExpiry.toString(),
      })
      .expire(`forgot-password-otp:${email}`, 5 * 60)
      .exec();

    sendForgotPasswordOTP(email, newOtp);

    return reply.status(200).send({
      success: true,
      message: "New OTP sent successfully",
      otp: process.env.NODE_ENV === "development" ? newOtp : null,
    });
  } catch (error) {
    request.log.error(error);
    return reply.status(500).send({
      success: false,
      // message: "Internal Server Error",
      message: "Flutter Developer durbol!",
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }
};